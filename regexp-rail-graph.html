<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>regexp-rail-graph</title>
</head>
<body>
<script>
	let reg = /foo|(bar|(ba+z{2,5})[aeiou])/

	/**
	 * 解析正则表达式
	 * @param input
	 */
	function parseRegularExpression(input) {
		let i = 0
		let groupIndex = 1 // 分组的序号，从1开始
		let branches = parseBranches()
		return {
			type: 'RegularExpression',
			start: 0,
			end: i,
			branches,
		}

		/**
		 * 解析每个分支的一个部分
		 */
		function parseOnePart() {
			if (input[i] === '[') {
				return parseCharacterClass()
			} else if (input[i] === '(') {
				return parseCaptureGroup()
			} else if (input[i] === '?' || input[i] === '*' || input[i] === '+' || input[i] === '{') {
				return parseQuantifier()
			} else if (input[i] === '\\') {
				return parseEscape()
			} else {
				return parseCharacter()
			}
		}

		/**
		 * 解析所有分支（数组）
		 */
		function parseBranches() {
			let branches = [] // 获取每一个分支的集合
			while (input[i] !== ')' && i < input.length) {
				let branch = parseBranch()
				branches.push(branch) // 完事后i会停到'|' or ')' or > input.length position
				if (input[i] === '|') { // branches遇到()里面代表多个分支，但是遇到|只表示一个分支走完，那当然需要继续走了
					i++ // skip '|'
				}
			}
			return branches
		}

		/**
		 * 解析单个分支
		 */
		function parseBranch() {
			let node = {
				type: 'Branch',
				start: i,
				end: 0,
				raw: '',
				elements: [], // 一个分支里面的每个不同的部分
			}
			// 一个分支可能是一个括号，|还有可能是一整个表达式 ---> \jfalfjoo\
			// debugger
			while (input[i] !== '|' && input[i] !== ')' && i < input.length) {
				let element = parseOnePart() // 一个分支有很多的部分需要解析
				// 这个对象是量词
				if (element.type === 'Quantifier') {
					if (node.elements.length === 0) {
						throw new SyntaxError('Quantifier: Nothing to repeat for ahead!')
					}
					let prevElement = node.elements.pop() // 取出紧跟量词前的一个字符对象
					element.repeatElement = prevElement
					element.start = prevElement.start
					element.raw = input.slice(element.start, element.end)
				}
				node.elements.push(element)
			}
			node.end = i
			node.raw = input.slice(node.start, node.end)
			return node
		}

		/**
		 * 解析转义字符，暂时只解析 \\后跟一个字符
		 */
		function parseEscape() {
			let node = {
				type: 'Escape',
				start: i,
				end: 0,
				raw: '',
				escape: '', // 转义字符的那个字符内容
			}
			i++ // skip the \
			node.escape = input[i]
			i++ // 跳过被转义的那个字符
			node.end = i
			node.raw = input.slice(node.start, node.end)
			return node
		}

		/**
		 * 解析单个字符
		 */
		function parseCharacter() {
			let node = {
				type: 'Character',
				start: i,
				end: 0,
				raw: '',
				character: input[i],
			}
			i++ // skip
			node.end = i
			node.raw = input.slice(node.start, node.end)
			return node
		}

		/**
		 * 解析中括号括起来的字符
		 */
		function parseCharacterClass() {
			let node = {
				type: 'CharacterClass',
				start: i,
				end: 0,
				raw: '',
				invert: false, // 表示字符集是否取反：默认是不取反
				characterClasses: [], // 中括号的每个内容
			}
			i++ // skip the '['
			if (input[i] === '^') {
				node.invert = true
				i++ // skip the '^'
			}
			// 解析中括号里面的内容 [^abc\b0-9a-z]
			while (input[i] !== ']') {
				let part = parseOneClass()
				node.characterClasses.push(part)
			}
			i++ // skip the ']'
			node.end = i
			node.raw = input.slice(node.start, node.end)
			return node

			/**
			 * 解析中括号的某一部分：一个字符，一个转义
			 */
			function parseOneClass() {
				if (input[i] === '\\') {
					return parseEscape() // 解析转义
				} else {
					return parseCharacter() // 解析单个字符
				}
			}
		}

		/**
		 * 解析量词
		 */
		function parseQuantifier() {
			// 量词有：?, *, +, {1, 5}, {4, }
			let node = {
				type: 'Quantifier',
				start: i,
				end: 0,
				raw: '',
				min: 0,
				max: Infinity,
				greedy: true, // 表示贪婪匹配
				repeatElement: null, // 谁的量词
			}
			if (input[i] === '?') {
				i++ // skip the '?'
				node.max = 1
			} else if (input[i] === '*') {
				i++ // skip the '*'
			} else if (input[i] === '+') {
				i++
				node.min = 1
			} else if (input[i] === '{') {
				i++
				node.min = parseInteger()
				i++ // skip the ','
				if (input[i] === '}') {
					i++ // skip '}'
				} else {
					node.max = parseInteger()
					i++ // skip '}'
				}
			}
			if (input[i] === '?') {
				node.greedy = false // 不是贪婪
				i++ // skip '?'
			}
			node.end = i
			node.raw = input.slice(node.start, node.end)
			return node
		}

		/**
		 * 从i位置解析数字，i最后指向最后一个数字右边一个字符处
		 */
		function parseInteger() {
			let start = i
			while (input[i] >= '0' && input[i] <= '9') {
				i++
			}
			return Number(input.slice(start, i))
		}

		/**
		 * 解析捕获分组
		 */
		function parseCaptureGroup() {
			let node = {
				type: 'CaptureGroup',
				start: i,
				end: 0,
				raw: '',
				groupIndex: groupIndex, // 分组的编号
				capture: true, // 捕获分组
				zeroAssertion: false, // 是否是零宽断言
				positive: true, // 断言是否是正向还是反向断言
				lookahead: true, // 断言是向前看还是向后看
				groupName: null, // 具名分组
				branches: [] // 一个括号也就是分组中是可以有很多个分支的
			}
			/*
			(ofw|jf)如果不是? 那里面其实是多个分支（子分支），也就是branches
			(?:fls) // 非捕获分组
			(?=fal) position lookahead
			(?!fal) negative lookahead
			(?<=fal) position lookbehind
			(?<!fal) negative lookbehind
			(?<year>flafjl)具名分组
			 */
			i++ // skip the '('
			if (input[i] === '?') {
				i++ // skip the '?'
				if (input[i] === ':') {
					i++ // skip ':'
					node.capture = false
				} else if (input[i] === '=') {
					i++ // skip '='
					node.zeroAssertion = true
					node.positive = true
					node.lookahead = true
				} else if (input[i] === '!') {
					i++ // skip '!'
					node.zeroAssertion = true
					node.positive = false
					node.lookahead = true
				} else if (input[i] === '<') {
					i++ // skip '<'
					if (input[i] === '=') {
						i++ // skip '='
						node.zeroAssertion = true
						node.positive = true
						node.lookahead = false
					} else if (input[i] === '!') {
						i++ // skip '!'
						node.zeroAssertion = true
						node.positive = false
						node.lookahead = false
					} else {
						// 具名 分组
						node.groupName = parseGroupName()
						i++ // skip '>'
					}
				}
			}
			// 解析括号里面的内容
			node.branches = parseBranches()
			i++ // skip ')'
			// 当前括号不是零宽断言and是捕获分组即分组编号加1
			if (!node.zeroAssertion && node.capture) {
				groupIndex++
			}
			node.end = i
			node.raw = input.slice(node.start, node.end)
			return node

			/**
			 * 解析具名分组<name>
			 */
			function parseGroupName() {
				let start = i
				while (input[i] !== '>') {
					i++
				}
				return input.slice(start, i)
			}
		}
	}
</script>
</body>
</html>